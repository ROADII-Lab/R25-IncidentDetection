# Precursor to Grid_aggregation, follows Hex_UA_overlay_SDC
# Runs on SDC only at this point

# <><><><><><><><><><><><><><><><><><><><>
# Setup ----
rm(list = ls())
library(tidyverse)
library(lubridate)
library(utils)
library(doParallel) # DoParallel package is a "parallel backend" for the foreach package, it provides a mechanism needed to execute foreach loops in parallel.
library(foreach)

#Set parameters for data to process
grids = c("TN_01dd_fishnet",
          "TN_1sqmile_hexagons")

codeloc <- "~/SDI_Waze" 

# Flag for SDC work
ON_SDC = F
if(ON_SDC){teambucket <- "<Path_to_AWS_S3_Bucket_For_Waze_Data>"}

localdir <- normalizePath("~/TN/workingdata") # full path for readOGR

wazemonthdir <- file.path(localdir, "Overlay") # contains the merged.waze.tn.YYYY-mm_<state>.RData files
temp.outputdir = "~/TN/agg_out" # Will contain the WazeHexTimeList_YYYY-mm_grids_<state>.RData files generated by this script.

source(file.path(codeloc, "utility/wazefunctions.R")) 

setwd(wazemonthdir)

# <><><><><><><><><><><><><><><><><><><><>

if(ON_SDC){
  
# start grid loop ----
for(g in grids){ # g = grids[2]

  # Loop through months of available merged data for this state
  mergefiles <- dir(wazemonthdir)[grep("^merged.waze.tn", dir(wazemonthdir))]
  gridmergefiles <- mergefiles[grep(g, mergefiles)]
 
  avail.months = substr(unlist(lapply(strsplit(gridmergefiles, "_"), function(x) x[[4]])),
                        1, 7)
  
  # Look for already completed months and skip those. Edit to todo.months = avail.months to re-run (or just delete previously completed WazeHexTimeList files)
  tlfiles <- dir(temp.outputdir)[grep("WazeHexTimeList_", dir(temp.outputdir))]
  g.tlfiles <- tlfiles[grep(g, tlfiles)]
  done.months <- unlist(lapply(strsplit(g.tlfiles, "_"), function(x) x[[2]])) 

  todo.months = avail.months[!avail.months %in% done.months] 

  starttime <- Sys.time()
  
  if(exists('usecorepct')) {
      # make a cluster with limited number of cores 
      usecores = round(parallel::detectCores()*usecorepct)
      cl <- makeCluster(usecores) 
  
    } else {
      # make a cluster of all available cores 
      cl <- makeCluster(parallel::detectCores()) 
    }
  registerDoParallel(cl)
  
  writeLines(c(""), paste(g, "log.txt", sep = "_"))    
  
  foreach(j = todo.months, .packages = c("dplyr", "lubridate", "utils")) %dopar% { # j="2018-08" 

    sink(paste(g, "log.txt", sep = "_"), append=TRUE) # sink() function diverts R output to a connection and stops such diversions. Starting from this point, all output in console will be saved in the log file in the working directory.
    
    cat(paste(Sys.time()), g, j, "\n")                                                           
    load(file.path(wazemonthdir, paste0("merged.waze.tn.", g,"_", j, ".RData"))) # includes both waze (link.waze.tn) and TN crash (crash.df) data, with grid for central and neighboring cells
    
    # TN date, Waze time all now are POSIXct, with correct time zone. ct: seconds since beginning of 1970 in UTC. lt is a list of vectors representing seconds, min, hours, day, year. ct is better for analysis, while lt is more human-readable.

    ##############
    # Make data frame of all Grid IDs by day of year and time of day in each month of data (subset to all grid IDs with Waze OR EDT data)
    GridIDall <- unique(c(as.character(link.waze.tn$GRID_ID), # Grid ID for a Waze event
                          as.character(link.waze.tn$GRID_ID.TN)) # Grid ID for a TN crash
                        )
    
    # Date/time for TN crash only events or TN/Waze matching events are stored as 'date', while Date/time for Waze only events are stored as 'time'.
    year.month.w <- format(link.waze.tn$time, "%Y-%m")
    year.month.t <- format(link.waze.tn$date, "%Y-%m")
    year.month <- year.month.w
    year.month[is.na(year.month)] <- year.month.t[is.na(year.month)]
    
    link.waze.tn <- link.waze.tn[year.month == j,]
    
    month.days.w  <- unique(as.numeric(format(link.waze.tn$time, "%d"))) # Waze event date/time
    month.days.t  <- unique(as.numeric(format(link.waze.tn$date, "%d"))) # TN crash date/time
    month.days = unique(c(month.days.w, month.days.t))
    
    lastday = max(month.days[!is.na(month.days)])
    
    Month.hour <- seq(from = as.POSIXct(paste0(j,"-01 0:00"), tz = 'America/Chicago'), 
                      to = as.POSIXct(paste0(j,"-", lastday, " 24:00"), tz = 'America/Chicago'), 
                      by = "hour")
    
    # Remove time zone to put everything in local time
    Date <- format(Month.hour, "%Y-%m-%d")
    Hour <- format(Month.hour, "%H")
    Date.hour <- paste(Date, Hour)
    
    # Make the same format for Waze and TN crash data
    link.waze.tn$wDate <- format(link.waze.tn$time, "%Y-%m-%d")
    link.waze.tn$wHour <- as.numeric(format(link.waze.tn$time, "%H"))
    
    link.waze.tn$wDate.last <- format(link.waze.tn$last.pull.time, "%Y-%m-%d")
    link.waze.tn$wHour.last <- as.numeric(format(link.waze.tn$last.pull.time, "%H"))

    link.waze.tn$tDate <- format(link.waze.tn$date, "%Y-%m-%d")
    link.waze.tn$tHour <- as.numeric(format(link.waze.tn$date, "%H"))

    GridIDTime <- expand.grid(Date.hour, GridIDall)
    names(GridIDTime) <- c("GridDayHour", "GRID_ID")
    GridIDTime$Date <- substr(GridIDTime$GridDayHour, 1, 10)
    GridIDTime$Hour <- as.numeric(substr(GridIDTime$GridDayHour, 12, 13))
    
    # GRID_ID as character to for faster joining in the loop 
    GridIDTime$GRID_ID <- as.character(GridIDTime$GRID_ID)
    link.waze.tn$GRID_ID <- as.character(link.waze.tn$GRID_ID)
    
    # Temporally matching
    # Match between the first reported time and last pull time of the Waze event. 
    StartTime <- Sys.time()
    
    Waze.hex.time.all <- vector()
    
    # Loop over all hours of this month
    for(t in 1:length(Date.hour)){
      ti.GridIDTime = GridIDTime %>% filter(GridDayHour == Date.hour[t])
      
      ti.link.waze.tn = link.waze.tn %>% 
        filter(wDate == unique(ti.GridIDTime$Date) &
                 ( wHour == unique(ti.GridIDTime$Hour) | wHour.last == unique(ti.GridIDTime$Hour) ) ) # Match Waze events time. Unique() must result in a single value for Date and Hour.
      
      ti.link.waze.tn.t = link.waze.tn %>% 
        filter(tDate == unique(ti.GridIDTime$Date) &
                 tHour == unique(ti.GridIDTime$Hour) ) # Match TN events time. 

      ti.Waze.hex <- inner_join(ti.GridIDTime, ti.link.waze.tn, by = "GRID_ID") # Use left_join to get zeros if no match  
      ti.Waze.hex.t <- inner_join(ti.GridIDTime, ti.link.waze.tn.t, by = "GRID_ID") # Same, for TN only crashes
      
      Waze.hex.time.all <- rbind(Waze.hex.time.all, ti.Waze.hex)
      Waze.hex.time.all <- rbind(Waze.hex.time.all, ti.Waze.hex.t)
      
      if(unique(ti.GridIDTime$Hour) == 0) cat(paste(Date.hour[t], "\n"))
     } # end loop
    
    EndTime <- Sys.time() - StartTime
    cat(round(EndTime, 2), attr(EndTime, "units"), "\n")
    
    Waze.hex.time <- unique(Waze.hex.time.all) # Rows with match = "M" are duplicated, so we want to remove the duplicates.
    
    # Use TN-only grid IDs if no Waze event present. Otherwise, TN only events (match==T) are omitted.
    Waze.hex.time$GRID_ID.TN = as.character(Waze.hex.time$GRID_ID.TN)
    
    Waze.hex.time$GRID_ID[is.na(Waze.hex.time$GRID_ID)] = Waze.hex.time$GRID_ID.TN[is.na(Waze.hex.time$GRID_ID)]
    Waze.hex.time <- filter(Waze.hex.time, !is.na(GRID_ID))
    
    # Save list of Grid cells and time windows with EDT or Waze data  
    fn = paste0("WazeHexTimeList_", j,"_", g, "TN.RData")
    
    save(list="Waze.hex.time", file = file.path(temp.outputdir, fn))
    
    # Copy to S3
    system(paste("aws s3 cp",
                 file.path(temp.outputdir, fn),
                 file.path(teambucket, "TN", fn)))
    
    cat("Completed", j, "\n")
    } # End SpaceTimeGrid loop ----
  
  stopCluster(cl); gc()
  
} # end grid loop

} # End if ON_SDC ----